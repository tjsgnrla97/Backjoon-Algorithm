#1로 만들기 2
n = int(input())
# DP 테이블 (x를 만드는 최소 연산의 수, [x를 최소 연산으로 만드는 경로])
dp = [[0,[]] for _ in range(n+1)]
# DP 테이블에 f(1)의 경우를 초기화
dp[1][0] = 0
dp[1][1] = [1]

for X in range(2, n+1):
    #가장 먼저, f(x-1)+1을 통해 dp 테이블 채우기
    dp[X][0] = dp[X-1][0] + 1
    dp[X][1] = dp[X-1][1] + [X]

    #이후, X가 2로 나눠지는 경우,
    if(X % 2 == 0):
        #f(X//2)+1과 기존 DP 테이블 값을 비교, 최솟값 갱신
        if dp[X//2][0]+1 < dp[X][0]:
            dp[X][0] = dp[X//2][0] + 1
            dp[X][1] = dp[X//2][1] + [X]

    #이후, X가 3으로 나눠지는 경우,
    if(X % 3 == 0):
        #f(X//3)+1과 기존 DP 테이블 값을 비교, 최솟값 갱신
        if dp[X//3][0]+1 < dp[X][0]:
            dp[X][0] = dp[X//3][0] + 1
            dp[X][1] = dp[X//3][1] + [X]

#x를 만드는 최소 연산 수
print(dp[n][0])
#x를 최소 연산으로 만드는 경로
for num in dp[n][1][::-1]:
    print(num, end=" ")